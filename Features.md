# ApplicationAccess

## About

ApplicationAccess is a containerized, REST-based service for authorization and permission/privilege management.

It manages users of a client application, and mappings of those users to groups and components within the client application.  It provides minimal latency when servicing requests from the client application by maintaining its data model in memory (and writing changes downstream to persistent storage).  The persisted data model is fully temporal allowing an accurate, point-in-time view of any historic state of the data.

ApplicationAccess supports varying deployment profiles, from a single docker container up to sharded, scalable, multi-node, Kubernetes deployments.

Further detail of the functionality offered can be found in the [project README](https://github.com/alastairwyse/ApplicationAccess/blob/main/README.md), and the complete [API surface is documented below](#rest-endpoints).

## Features

* [**Temporal Data Model**](https://en.wikipedia.org/wiki/Temporal_database) - All databases supported by ApplicationAccess (SQL Server, PostgreSQL, MongoDB) utilize a temporal data model which allows fast querying of the complete state of the data at any historic point in time.

* [**CQRS**](https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation) - In distributed deployment scenarios, read and write operations are handled by separate nodes, allowing the deployment to be scaled to suit either read-heavy, or write-heavy workloads.

* [**Event**](https://martinfowler.com/eaaDev/EventSourcing.html) [**Sourcing**](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) - ApplicationAccess fundamentally adopts an event sourcing design paradigm, whereby all operations which change data are captured as a sequence of events.  This simplifies and enables many of ApplicationAccess's more advanced features...
  * **CQRS** - Reader nodes can be kept synchronized simply by consuming the sequence of events generated by their associated writer node.
  * **Redistribution** - Expanding or shrinking a deployment (by splitting or merging nodes) is achieved by replaying and splitting or merging sequences of events.  This is far simpler approach than attempting to split or (particularly) merge in-place temporal databases.
  * **Testing** - Sequences of test or real-world events can be easily stored and replayed against an ApplicationAccess instance.  This provides a mechanism to accurately assess the impact/effect of changes, and to run repeated/standardized integration tests with real production data, among many other test-related benefits.
  * The ApplicationAccess data model avoids a common issue in event sourced systems concerning the cost of rendering/materializing the current or historic state of data.  Since the data model is primarily temporal, the data state at any histoic point in time can be queried quickly.  However suplementary tables and collections are included which make it simple to recreate and export the complete event sequence history.  This provides a 'best of both worlds' solution where all the benefits of event sourcing are realized, whilst avoiding the usual costs of rendering/materializing the complete data state.

* **Dynamic Data Redistribution and Resharding** - In distributed Kubernetes deployment scenarios, ApplicationAccess can split (to scale up) or merge (to scale down) groups of nodes to adjust to changing workloads in realtime (i.e. whilst continuing to process queries and change events).  This includes redistribution of database persisted data, and redistribution of the 'live' data model held in memory in each of the nodes.  Event sourcing is leveraged to support redistribution, with the bulk of split/merge processes being carried out in the background, and operation processing paused for a brief moment as the final set of events are processed, and future processing responsibility is handed over to the destination nodes of the split or merge.  The [DistributedAccessManagerOperationRouter](https://github.com/alastairwyse/ApplicationAccess/blob/main/ApplicationAccess.Distribution/DistributedAccessManagerOperationRouter.cs) class is fundamental to this process, handling routing of operations to source and target nodes, and pausing/holding any incoming operations during the final handover in a split or merge.

* [**Consistent Hashing**](https://en.wikipedia.org/wiki/Consistent_hashing) - Consistent Hashing is used in distributed deployment scenarios to assign elements within the application (users and groups) to a range of hash codes.  The same technique is used to assign groups of reader and writer nodes (known as a 'shard group') ranges of hash codes which they are responsible for managing.

* **Advanced Resilience and Recovery Features**
  * **Backup/Secondary Data Persistence** - If writing to the database fails, ApplicationAccess will store all failed/remaining changes to file (local or network drive). Once restarted it will write these stored changes to the database.
  * **Automatic Retries for Transient Errors** - Transient network errors (for connectivity between nodes) and database errors are automatically retried. The number of retries and interval can be configured.
  * **Database Deadlock Retries** - The SQL Server database implementation will retry operations rolled back by database deadlocks (again, retry count and interval is configurable).
  * **Tripswitch** - If an unrecoverable error occurs in a critical part of the application (e.g. the database write/persistence thread, or synchronization between reader and writer nodes), the tripswitch mechanism is 'tripped'... which either rejects any subsequent requests (and hence prevents accepting changes which will fail to write and be lost, or prevents responding to queries with a stale data state), or shuts down the service (and hence can leverage mechanisms like the [Kubernetes restart policy](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy) to automatically restart).

* **Concurrency Management**
  * Any object locks required as part of event writing are handled by a dedicated LockManager class, which guarantees to apply locks in a consistent order and hence avoid deadlocks.
  * Base classes provding thread-safe core functionality (e.g. [ConcurrentAccessManager](https://github.com/alastairwyse/ApplicationAccess/blob/main/ApplicationAccess/ConcurrentAccessManager.cs)) expose methods which allow sub/derived classes to extend functinality, executing additional code/routines whilst still under lock context.  This allows these derived classes to implement extended functionality whist still maintaining thread-safety, and without requiring changes to the core/base classes.

* **Metrics / Observability** - The [ApplicationMetrics](https://github.com/alastairwyse/ApplicationMetrics) package is extensively utilized to provide highly detailed and granular metrics if required.  Raw/granular metrics can be stored in a SQL Server or PostgreSQL database, or exported to any platform supporting the OpenTelemetry protocol (Grafana, Elastic, Splunk, cloud provders, etc...).

* **Exception Propagation** - ApplicationAccess includes middleware functionality which propagates details of exceptions (including the inner exception stack) between nodes via REST or gRPC.  Such exceptions are rethrown in the receipient node, allowing the node access to the full context of the exception, and act accordingly.  This provides an ability for richer inter-node exception handling than is possible with more flat exception message format standards (like [RFC 7807 Problem Details](https://datatracker.ietf.org/doc/html/rfc7807))

* **REST and gRPC Status Code Mapping** - Status codes returned by API calls are mapped automatically from configured exceptions via middleware (in the case of REST) and interceptors (in the case of gRPC).  This avoids excessive and repeated mapping code and try/catch blocks having to be included in API controller methods.

* **Code Reuse** - The core AccessManger class is used verbatim throughout different deployment profiles (standalone, multi-reader nodes, sharded/distributed), plus for ancillary purposes like data validation.  Object oriented language features (primarily inheritance) and layered design are used to add features like thread concurrency handling, metrics capture, and idempotency (via sub/derived classes), whilst leaving the core classes unchanged.

* [**Separation of Concerns**](https://en.wikipedia.org/wiki/Separation_of_concerns) - ApplicationAccess is deliberately split into many (90+) distinct namespaces implemented as separate .NET projects (meaning they can each be compiled individually).  Each project/namespace has a clearly defined purpose and area of concern.  This helps to ensure significant changes can be isolated to relevant target areas, and hence introduced to the code base with minimal risk and effort.   Changes can also be introduced using a piecewise/phased approach by virtue of being split into multiple distinct projects.

* [**Generics**](https://en.wikipedia.org/wiki/Generic_programming) - The project makes extensive use of generic classes and methods, to minimize repeated code, and and hence to reduce the risk of introducing bugs when implementing change and enhancements.

* **Testing** - ApplicationAccess has been through 1000's of hours of pseudorandom load, stress, and performance testing, to ensure the final product is robust, performant, and bug-free.

## REST Endpoints

| URL Path | Method | Description |
| -------- | ------ | ----------- |
| /users/{user} | POST | Adds a user. |
| /users/{user} | DELETE | Removes a user. |
| /users/{user} | GET | Returns the specified user if it exists. |
| /userToGroupMappings/user/{user}/group/{group} | POST | Adds a mapping between the specified user and group. |
| /userToGroupMappings/user/{user}/group/{group} | DELETE | Removes the mapping between the specified user and group. |
| /userToApplicationComponentAndAccessLevelMappings/user/{user}/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | POST | Adds a mapping between the specified user, application component, and level of access to that component. |
| /userToApplicationComponentAndAccessLevelMappings/user/{user}/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | DELETE | Removes a mapping between the specified user, application component, and level of access to that component. |
| /userToEntityMappings/user/{user}/entityType/{entityType}/entity/{entity} | POST | Adds a mapping between the specified user, and entity. |
| /userToEntityMappings/user/{user}/entityType/{entityType}/entity/{entity} | DELETE | Removes a mapping between the specified user, and entity. |
| /users | GET | Returns all users. |
| /userToGroupMappings/user/{user} | GET | Gets the groups that the specified user is mapped to (i.e. is a member of). |
| /userToGroupMappings/group/{group} | GET | Gets the users that are mapped to the specified group. |
| /userToApplicationComponentAndAccessLevelMappings/user/{user} | GET | Gets the application component and access level pairs that the specified user is mapped to. |
| /userToApplicationComponentAndAccessLevelMappings/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | GET | Gets users that are mapped to the specific application component and access level pair. |
| /userToEntityMappings/user/{user} | GET | Gets the entities that the specified user is mapped to. |
| /userToEntityMappings/user/{user}/entityType/{entityType} | GET | Gets the entities of a given type that the specified user is mapped to. |
| /userToEntityMappings/entityType/{entityType}/entity/{entity} | GET | Gets the users that are mapped to the specified entity. |
| /groups/{group} | POST | Adds a group. |
| /groups/{group} | DELETE | Removes a group. |
| /groups/{group} | GET | Returns the specified group if it exists. |
| /groupToApplicationComponentAndAccessLevelMappings/group/{group}/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | POST | Adds a mapping between the specified group, application component, and level of access to that component. |
| /groupToApplicationComponentAndAccessLevelMappings/group/{group}/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | DELETE | Removes a mapping between the specified group, application component, and level of access to that component. |
| /groupToEntityMappings/group/{group}/entityType/{entityType}/entity/{entity} | POST | Adds a mapping between the specified group, and entity. |
| /groupToEntityMappings/group/{group}/entityType/{entityType}/entity/{entity} | DELETE | Removes a mapping between the specified group, and entity. |
| /groups | GET | Returns all groups. |
| /groupToApplicationComponentAndAccessLevelMappings/group/{group} | GET | Gets the application component and access level pairs that the specified group is mapped to. |
| /groupToApplicationComponentAndAccessLevelMappings/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | GET | Gets the groups that are mapped to the specified application component and access level pair. |
| /groupToEntityMappings/group/{group} | GET | Gets the entities that the specified group is mapped to. |
| /groupToEntityMappings/group/{group}/entityType/{entityType} | GET | Gets the entities of a given type that the specified group is mapped to. |
| /groupToEntityMappings/entityType/{entityType}/entity/{entity} | GET | Gets the groups that are mapped to the specified entity. |
| /groupToGroupMappings/fromGroup/{fromGroup}/toGroup/{toGroup} | POST | Adds a mapping between the specified groups. |
| /groupToGroupMappings/fromGroup/{fromGroup}/toGroup/{toGroup} | DELETE | Removes the mapping between the specified groups. |
| /groupToGroupMappings/group/{group} | GET | Gets the groups that the specified group is mapped to. |
| /groupToGroupReverseMappings/group/{group} | GET | Gets the groups that are mapped to the specified group. |
| /entityTypes/{entityType} | POST | Adds an entity type. |
| /entityTypes/{entityType} | DELETE | Removes an entity type. |
| /entityTypes/{entityType} | GET | Returns the specified entity type if it exists. |
| /entityTypes/{entityType}/entities/{entity} | POST | Adds an entity. |
| /entityTypes/{entityType}/entities/{entity} | DELETE | Removes an entity. |
| /entityTypes/{entityType}/entities/{entity} | GET | Returns the specified entity if it exists. |
| /entityTypes | GET | Returns all entity types. |
| /entityTypes/{entityType}/entities | GET | Returns all entities of the specified type. |
| /dataElementAccess/applicationComponent/user/{user}/applicationComponent/{applicationComponent}/accessLevel/{accessLevel} | GET | Checks whether the specified user (or a group that the user is a member of) has access to an application component at the specified level of access. |
| /dataElementAccess/entity/user/{user}/entityType/{entityType}/entity/{entity} | GET | Checks whether the specified user (or a group that the user is a member of) has access to the specified entity. |