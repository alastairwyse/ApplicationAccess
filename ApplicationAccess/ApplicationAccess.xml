<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ApplicationAccess</name>
    </assembly>
    <members>
        <member name="T:ApplicationAccess.AccessManager`4">
            <summary>
            Manages the access of users and groups of users to components and entities within an application.
            </summary>
            <typeparam name="TUser">The type of users in the application.</typeparam>
            <typeparam name="TGroup">The type of groups in the application.</typeparam>
            <typeparam name="TComponent">The type of components in the application to manage access to.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
            <remarks>Note that all generic type parameters must implement relevant methods to allow storing in a <see cref="T:System.Collections.Generic.HashSet`1"/> (at minimum <see cref="T:System.IEquatable`1"/> and <see cref="M:System.Object.GetHashCode">GetHashcode()</see>).  This is not enforced as a generic type contraint in order to allow the type parameters to be enums.</remarks>
        </member>
        <member name="M:ApplicationAccess.AccessManager`4.#ctor(System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.AccessManager class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="T:ApplicationAccess.AccessManagerBase`4">
            <summary>
            A base class for managing the access of users and groups of users to components and entities within an application.
            </summary>
            <typeparam name="TUser">The type of users in the application.</typeparam>
            <typeparam name="TGroup">The type of groups in the application.</typeparam>
            <typeparam name="TComponent">The type of components in the application to manage access to.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
            <remarks>Note that all generic type parameters must implement relevant methods to allow storing in a <see cref="T:System.Collections.Generic.HashSet`1"/> (at minimum <see cref="T:System.IEquatable`1"/> and <see cref="M:System.Object.GetHashCode">GetHashcode()</see>).  This is not enforced as a generic type contraint in order to allow the type parameters to be enums.</remarks>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.collectionFactory">
            <summary>Creates instances of collection classes.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.userToGroupMap">
            <summary>The DirectedGraph which stores the user to group mappings.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.userToComponentMap">
            <summary>A dictionary which stores mappings between a user, and application component, and a level of access to that component.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.groupToComponentMap">
            <summary>A dictionary which stores mappings between a group, and application component, and a level of access to that component.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.entities">
            <summary>Holds all valid entity types and values within the access manager.  The Dictionary key holds the types of all entities, and each respective value holds the valid entity values within that type (e.g. the entity type could be 'ClientAccount', and values could be the names of all client accounts).</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.userToEntityMap">
            <summary>A dictionary which stores user to entity mappings.  The value stores another dictionary whose key contains the entity type and whose value contains the name of all entities of the specified type which are mapped to the user.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.groupToEntityMap">
            <summary>A dictionary which stores group to entity mappings.  The value stores another dictionary whose key contains the entity type and whose value contains the name of all entities of the specified type which are mapped to the group.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.storeBidirectionalMappings">
            <summary>Whether to store bidirectional mappings between elements.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.userToEntityReverseMap">
            <summary>The reverse of the mappings in member 'userToEntityMap'.</summary>
        </member>
        <member name="F:ApplicationAccess.AccessManagerBase`4.groupToEntityReverseMap">
            <summary>The reverse of the mappings in member 'groupToEntityMap'.</summary>
        </member>
        <member name="P:ApplicationAccess.AccessManagerBase`4.Users">
            <inheritdoc/>
        </member>
        <member name="P:ApplicationAccess.AccessManagerBase`4.Groups">
            <inheritdoc/>
        </member>
        <member name="P:ApplicationAccess.AccessManagerBase`4.EntityTypes">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.#ctor(ApplicationAccess.ICollectionFactory,ApplicationAccess.DirectedGraphBase{`0,`1},System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.AccessManagerBase class.
            </summary>
            <param name="collectionFactory">>Creates instances of collection classes.</param>
            <param name="userToGroupMap">The user to group map the access manager should use internally.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.Clear">
            <summary>
            Removes all items and mappings from the access manager.
            </summary>
            <remarks>Since the Clear() method on HashSets and Dictionaries underlying the class are O(n) operations, performance will scale roughly with the number of items and mappings stored in the access manager.</remarks>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.ContainsUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveUser(`0)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.ContainsGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddUserToGroupMapping(`0,`1)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToGroupMappings(`0,System.Boolean)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveUserToGroupMapping(`0,`1)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetGroupToGroupMappings(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToApplicationComponentAndAccessLevelMappings(`0)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetGroupToApplicationComponentAndAccessLevelMappings(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.ContainsEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetEntities(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.ContainsEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToEntityMappings(`0)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToEntityMappings(`0,System.String)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.AddGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetGroupToEntityMappings(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetGroupToEntityMappings(`1,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.HasAccessToApplicationComponent(`0,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.HasAccessToEntity(`0,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetApplicationComponentsAccessibleByUser(`0)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetApplicationComponentsAccessibleByGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetEntitiesAccessibleByUser(`0)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetEntitiesAccessibleByUser(`0,System.String)">
            <inheritdoc/>
            <exception cref="T:ApplicationAccess.UserNotFoundException`1">The specified user does not exist.</exception>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetEntitiesAccessibleByGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetEntitiesAccessibleByGroup(`1,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveEntityType(System.String,System.Action{`0,System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32},System.Action{`1,System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32})">
            <summary>
            Removes an entity type.
            </summary>
            <param name="entityType">The entity type to remove.</param>
            <param name="userToEntityTypeMappingPreRemovalAction">An action which is invoked before removing the entity type mappings for a user.  Accepts 4 parameters: the user in the mappings, the type of the entity of the mappings being removed, the entities in the mappings, and the number of entities in the mappings.</param>
            <param name="groupToEntityTypeMappingPreRemovalAction">An action which is invoked before removing the entity type mappings for a group.  Accepts 4 parameters: the group in the mappings, the type of the entity of the mappings being removed, the entities in the mappings, and the number of entities in the mappings.</param>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.RemoveEntity(System.String,System.String,System.Action{`0,System.String,System.String},System.Action{`1,System.String,System.String})">
            <summary>
            Removes an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to remove.</param>
            <param name="userToEntityMappingPostRemovalAction">An action which is invoked after removing a user to entity mapping.  Accepts 3 parameters: the user in the mapping, the type of the entity in the mapping, and the entity in the mapping.</param>
            <param name="groupToEntityMappingPostRemovalAction">An action which is invoked after removing a group to entity mapping.  Accepts 3 parameters: the group in the mapping, the type of the entity in the mapping, and the entity in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToEntityMappingsImplementation(`0)">
            <summary>
            Gets the entities that the specified user is mapped to.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the specified user is mapped to.</returns>
            <remarks>Putting implementation of GetUserToEntityMappings() in this method allows methods like GetEntitiesAccessibleByUser() to call this method rather than the public virtual GetUserToEntityMappings().  Calling the public virtual version from GetUserToEntityMappings() can result is overridden implementations being called, and hence unexpected behaviour (specifically metrics being logged unnecessarily).</remarks>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetGroupToEntityMappingsImplementation(`1)">
            <summary>
            Gets the entities that the specified group is mapped to.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the specified group is mapped to.</returns>
            <remarks>Putting implementation of GetUserToEntityMappings() in this method allows methods like GetEntitiesAccessibleByUser() to call this method rather than the public virtual GetUserToEntityMappings().  Calling the public virtual version from GetUserToEntityMappings() can result is overridden implementations being called, and hence unexpected behaviour (specifically metrics being logged unnecessarily).</remarks>
        </member>
        <member name="M:ApplicationAccess.AccessManagerBase`4.GetUserToEntityMappingsImplementation(`0,System.String)">
            <summary>
            Gets the entities of a given type that the specified user is mapped to.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <param name="entityType">The entity type to retrieve the mappings for.</param>
            <returns>A collection of entities that the specified user is mapped to.</returns>
            <remarks>Putting implementation of GetUserToEntityMappings() in this method allows methods like GetEntitiesAccessibleByUser() to call this method rather than the public virtual GetUserToEntityMappings().  Calling the public virtual version from GetUserToEntityMappings() can result is overridden implementations being called, and hence unexpected behaviour (specifically metrics being logged unnecessarily).</remarks>
        </member>
        <member name="T:ApplicationAccess.ApplicationComponentAndAccessLevel`2">
            <summary>
            Container class which holds an application component and a level of access of that component.
            </summary>
            <typeparam name="TComponent">The type of the application component.</typeparam>
            <typeparam name="TAccess">The type of the access level.</typeparam>
        </member>
        <member name="P:ApplicationAccess.ApplicationComponentAndAccessLevel`2.ApplicationComponent">
            <summary>
            The application component.
            </summary>
        </member>
        <member name="P:ApplicationAccess.ApplicationComponentAndAccessLevel`2.AccessLevel">
            <summary>
            The level of access.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ApplicationComponentAndAccessLevel`2.#ctor(`0,`1)">
            <summary>
            Initialises a new instance of the ApplicationAccess.AccessManager+ApplicationComponentAndAccessLevel class.
            </summary>
            <param name="applicationComponent">The application component.</param>
            <param name="accessLevel">The level of access.</param>
        </member>
        <member name="M:ApplicationAccess.ApplicationComponentAndAccessLevel`2.Equals(ApplicationAccess.ApplicationComponentAndAccessLevel{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ApplicationComponentAndAccessLevel`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:ApplicationAccess.CircularReferenceException">
            <summary>
            The exception that is thrown when the specified action would result in a circular reference within a DirectedGraph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.CircularReferenceException.#ctor(System.String)">
            <summary>
            Initialises a new instance of the ApplicationAccess.CircularReferenceException class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:ApplicationAccess.ConcurrentAccessManager`4">
            <summary>
            A thread-safe version of the <see cref="T:ApplicationAccess.AccessManager`4"/> class, which can be accessed and modified by multiple threads concurrently.
            </summary>
            <typeparam name="TUser">The type of users in the application.</typeparam>
            <typeparam name="TGroup">The type of groups in the application.</typeparam>
            <typeparam name="TComponent">The type of components in the application to manage access to.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
            <remarks>Thread safety is implemented by using concurrent collections internally to represent the user, group, component, access level, and entity mappings (allows for concurrent read and enumeration operations), and locks to serialize modification operations.  Note that all generic type parameters must implement relevant methods to allow storing in a <see cref="T:System.Collections.Generic.HashSet`1"/> (at minimum <see cref="T:System.IEquatable`1"/> and <see cref="M:System.Object.GetHashCode">GetHashcode()</see>).  This is not enforced as a generic type contraint in order to allow the type parameters to be enums.</remarks>
        </member>
        <member name="F:ApplicationAccess.ConcurrentAccessManager`4.lockManager">
            <summary>Manages acquiring locks on underlying sets and dictionaries.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentAccessManager`4.usersLock">
            <summary>Lock object for the users collection of the base class directed graph member.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentAccessManager`4.groupsLock">
            <summary>Lock object for the groups collection of the base class directed graph member.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentAccessManager`4.userToGroupMapLock">
            <summary>Lock object for the user to group map of the base class directed graph member.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentAccessManager`4.groupToGroupMapLock">
            <summary>Lock object for the group to group map of the base class directed graph member.</summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.#ctor(System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentAccessManager class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.#ctor(ApplicationAccess.ConcurrentDirectedGraph{`0,`1},System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentAccessManager class.
            </summary>
            <param name="concurrentDirectedGraph">The ConcurrentDirectedGraph instance to use to store users and groups.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.#ctor(ApplicationAccess.ICollectionFactory,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentAccessManager class.
            </summary>
            <param name="collectionFactory">A mock collection factory.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>This constructor is included to facilitate unit testing.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.Clear">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUser(`0,System.Action{`0})">
            <summary>
            Adds a user.
            </summary>
            <param name="user">The user to add.</param>
            <param name="postProcessingAction">An action to invoke after adding the user but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUser(`0,System.Action{`0})">
            <summary>
            Removes a user.
            </summary>
            <param name="user">The user to remove.</param>
            <param name="postProcessingAction">An action to invoke after removing the user but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroup(`1,System.Action{`1})">
            <summary>
            Adds a group.
            </summary>
            <param name="group">The group to add.</param>
            <param name="postProcessingAction">An action to invoke after adding the group but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroup(`1,System.Action{`1})">
            <summary>
            Removes a group.
            </summary>
            <param name="group">The group to remove.</param>
            <param name="postProcessingAction">An action to invoke after removing the group but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToGroupMapping(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToGroupMapping(`0,`1,System.Action{`0,`1})">
            <summary>
            Adds a mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToGroupMapping(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToGroupMapping(`0,`1,System.Action{`0,`1})">
            <summary>
            Removes the mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToGroupMapping(`1,`1,System.Action{`1,`1})">
            <summary>
            Adds a mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToGroupMapping(`1,`1,System.Action{`1,`1})">
            <summary>
            Removes the mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3})">
            <summary>
            Adds a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3})">
            <summary>
            Removes a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3})">
            <summary>
            Adds a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3})">
            <summary>
            Removes a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntityType(System.String,System.Action{System.String})">
            <summary>
            Adds an entity type.
            </summary>
            <param name="entityType">The entity type to add.</param>
            <param name="postProcessingAction">An action to invoke after adding the entity type but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntityType(System.String,System.Action{System.String})">
            <summary>
            Removes an entity type.
            </summary>
            <param name="entityType">The entity type to remove.</param>
            <param name="postProcessingAction">An action to invoke after removing the entity type but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntity(System.String,System.String,System.Action{System.String,System.String})">
            <summary>
            Adds an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to add.</param>
            <param name="postProcessingAction">An action to invoke after adding the entity but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntity(System.String,System.String,System.Action{System.String,System.String})">
            <summary>
            Removes an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to remove.</param>
            <param name="postProcessingAction">An action to invoke after removing the entity but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String})">
            <summary>
            Adds a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String})">
            <summary>
            Removes a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String})">
            <summary>
            Adds a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after adding the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String})">
            <summary>
            Removes a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="postProcessingAction">An action to invoke after removing the mapping but whilst any mutual-exclusion locks are still acquired.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.InitializeLockObjects">
            <summary>
            Initializes the classes' lock objects and dependencies.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.Clear(System.Action{System.Action})">
            <summary>
            Removes all items and mappings from the access manager.
            </summary>
            <param name="wrappingAction">An action which wraps the operation to clear the access manager, allowing arbitrary code to be run before and/or after clearing, but whilst any mutual-exclusion locks are still acquired.  Accepts 1 parameter: the action which actually clears the access manager.</param>
            <remarks>
              <para>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to clear the access manager.</para>
              <para>Since the Clear() method on HashSets and Dictionaries underlying the class are O(n) operations, performance will scale roughly with the number of items and mappings stored in the access manager.</para>
            </remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUser(`0,System.Action{`0,System.Action})">
            <summary>
            Adds a user.
            </summary>
            <param name="user">The user to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the user, allowing arbitrary code to be run before and/or after adding the user, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the user being added, and the action which actually adds the user.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the user.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUser(`0,System.Action{`0,System.Action})">
            <summary>
            Removes a user.
            </summary>
            <param name="user">The user to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the user, allowing arbitrary code to be run before and/or after removing the user, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the user being removed, and the action which actually removes the user.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the user.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroup(`1,System.Action{`1,System.Action})">
            <summary>
            Adds a group.
            </summary>
            <param name="group">The group to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the group, allowing arbitrary code to be run before and/or after adding the group, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the group being added, and the action which actually adds the group.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the group.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroup(`1,System.Action{`1,System.Action})">
            <summary>
            Removes a group.
            </summary>
            <param name="group">The group to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the group, allowing arbitrary code to be run before and/or after removing the group, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the group being removed, and the action which actually removes the group.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the group.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToGroupMapping(`0,`1,System.Action{`0,`1,System.Action})">
            <summary>
            Adds a mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the user in the mapping, the group in the mapping, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToGroupMapping(`0,`1,System.Action{`0,`1,System.Action})">
            <summary>
            Removes the mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the user in the mapping, the group in the mapping, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToGroupMapping(`1,`1,System.Action{`1,`1,System.Action})">
            <summary>
            Adds a mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' group in the mapping, the 'to' group in the mapping, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToGroupMapping(`1,`1,System.Action{`1,`1,System.Action})">
            <summary>
            Removes the mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' group in the mapping, the 'to' group in the mapping, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3,System.Action})">
            <summary>
            Adds a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the user in the mapping, the application component in the mapping, the level of access to the component, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3,System.Action})">
            <summary>
            Removes a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the user in the mapping, the application component in the mapping, the level of access to the component, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3,System.Action})">
            <summary>
            Adds a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the group in the mapping, the application component in the mapping, the level of access to the component, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3,System.Action})">
            <summary>
            Removes a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the group in the mapping, the application component in the mapping, the level of access to the component, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntityType(System.String,System.Action{System.String,System.Action})">
            <summary>
            Adds an entity type.
            </summary>
            <param name="entityType">The entity type to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the entity type, allowing arbitrary code to be run before and/or after adding the entity type, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the entity type being added, and the action which actually adds the entity type.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the entity type.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntityType(System.String,System.Action{System.String,System.Action})">
            <summary>
            Removes an entity type.
            </summary>
            <param name="entityType">The entity type to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the entity type, allowing arbitrary code to be run before and/or after removing the entity type, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the entity type being removed, and the action which actually removes the entity type.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the entity type.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddEntity(System.String,System.String,System.Action{System.String,System.String,System.Action})">
            <summary>
            Adds an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the entity, allowing arbitrary code to be run before and/or after adding the entity, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the type of the entity, the entity being added, and the action which actually adds the entity.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the entity.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntity(System.String,System.String,System.Action{System.String,System.String,System.Action})">
            <summary>
            Removes an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the entity, allowing arbitrary code to be run before and/or after removing the entity, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the type of the entity, the entity being removed, and the action which actually removes the entity.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the entity.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String,System.Action})">
            <summary>
            Adds a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the user in the mapping, the type of the entity, the entity in the mapping, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String,System.Action})">
            <summary>
            Removes a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the user in the mapping, the type of the entity, the entity in the mapping, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.AddGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String,System.Action})">
            <summary>
            Adds a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to add the mapping, allowing arbitrary code to be run before and/or after adding the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the group in the mapping, the type of the entity, the entity in the mapping, and the action which actually adds the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to add the mapping.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String,System.Action})">
            <summary>
            Removes a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the mapping, allowing arbitrary code to be run before and/or after removing the mapping, but whilst any mutual-exclusion locks are still acquired.  Accepts 4 parameters: the group in the mapping, the type of the entity, the entity in the mapping, and the action which actually removes the mapping.</param>
            <remarks>Parameter 'wrappingAction' inner Action parameter must be invoked during the invocation of the outer 'wrappingAction' in order to remove the mapping.</remarks>
        </member>
        <member name="T:ApplicationAccess.ConcurrentCollectionFactory">
            <summary>
            Returns instances of concurrent collections in the System.Collections.Concurrent namespace.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentCollectionFactory.GetDictionaryInstance``2">
            <summary>
            Returns a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> instance.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns>The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> instance.</returns>
        </member>
        <member name="M:ApplicationAccess.ConcurrentCollectionFactory.GetSetInstance``1">
            <summary>
            Returns a <see cref="T:ApplicationAccess.ConcurrentHashSet`1"/> instance.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <returns>The <see cref="T:ApplicationAccess.ConcurrentHashSet`1"/> instance</returns>
        </member>
        <member name="T:ApplicationAccess.ConcurrentDirectedGraph`2">
            <summary>
            A thread-safe version of the DirectedGraph class, which can be accessed and modified by multiple threads concurrently.
            </summary>
            <typeparam name="TLeaf">The type of leaf vertices.</typeparam>
            <typeparam name="TNonLeaf">The type of non-leaf vertices.</typeparam>
            <remarks>Thread safety is implemented by using concurrent collections internally to represent the graph (allows for concurrent read and enumeration operations), and locks to serialize modification operations.</remarks>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.acquireLocks">
            <summary>Whether locks should be acquired before modifying underlying collection objects.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.lockManager">
            <summary>Manages acquiring locks on underlying sets and dictionaries.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.leafVerticesLock">
            <summary>Lock object for the leaf vertices collection.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.nonLeafVerticesLock">
            <summary>Lock object for the non-leaf vertices collection.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.leafToNonLeafEdgesLock">
            <summary>Lock object for the leaf to non-leaf map.</summary>
        </member>
        <member name="F:ApplicationAccess.ConcurrentDirectedGraph`2.nonLeafToNonLeafEdgesLock">
            <summary>Lock object for the non-leaf to non-leaf map.</summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.#ctor(System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentDirectedGraph class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings for edges within the graph.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings for edges in the graph are stored in both directions.  This avoids slow scanning of dictionaries which store the edge mappings in certain operations (like RemoveLeafToNonLeafEdge()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentDirectedGraph class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings for edges within the graph.</param>
            <param name="acquireLocks">Whether locks should be acquired before modifying underlying collection objects.</param>
            <remarks>
            <para>Parameter 'acquireLocks' should be set false where the ConcurrentDirectedGraph is used/composed within another class which acquires relevant locks before calling modification methods.  In all other cases, 'acquireLocks' should be set true.</para>
            <para>If parameter 'storeBidirectionalMappings' is set to True, mappings for edges in the graph are stored in both directions.  This avoids slow scanning of dictionaries which store the edge mappings in certain operations (like RemoveLeafToNonLeafEdge()), at the cost of addition storage and hence memory usage.</para>
            </remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.#ctor(ApplicationAccess.ICollectionFactory,System.Boolean,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentDirectedGraph class.
            </summary>
            <param name="collectionFactory">A mock collection factory.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings for edges within the graph.</param>
            <param name="acquireLocks">Whether locks should be acquired before modifying underlying collection objects.</param>
            <remarks>This constructor is included to facilitate unit testing.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddLeafVertex(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveLeafVertex(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddNonLeafVertex(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveNonLeafVertex(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddLeafToNonLeafEdge(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveLeafToNonLeafEdge(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddNonLeafToNonLeafEdge(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveNonLeafToNonLeafEdge(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.InitializeLockObjects">
            <summary>
            Initializes the classes' lock objects and dependencies.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.Clear(System.Action{System.Action})">
            <summary>
            Removes all vertices and edges from the graph.
            </summary>
            <param name="wrappingAction">An action which wraps the operation to clear the graph, allowing arbitrary code to be run before and/or after clearing the graph, but whilst any mutual-exclusion locks are still acquired.  Accepts 1 parameters: the action which actually clears the graph.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddLeafVertex(`0,System.Action{`0,System.Action})">
            <summary>
            Adds a leaf vertex to the graph.
            </summary>
            <param name="leafVertex">The leaf vertex to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the leaf vertex, allowing arbitrary code to be run before and/or after adding the leaf vertex, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the leaf vertex being added, and the action which actually adds the leaf vertex.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveLeafVertex(`0,System.Action{`0,System.Action})">
            <summary>
            Removes a leaf vertex from the graph.
            </summary>
            <param name="leafVertex">The leaf vertex to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the leaf vertex, allowing arbitrary code to be run before and/or after removing the leaf vertex, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the leaf vertex being removed, and the action which actually removes the leaf vertex.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddNonLeafVertex(`1,System.Action{`1,System.Action})">
            <summary>
            Adds a non-leaf vertex to the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to add.</param>
            <param name="wrappingAction">An action which wraps the operation to add the non-leaf vertex, allowing arbitrary code to be run before and/or after adding the non-leaf vertex, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the non-leaf vertex being added, and the action which actually adds the non-leaf vertex.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveNonLeafVertex(`1,System.Action{`1,System.Action})">
            <summary>
            Removes a non-leaf vertex from the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to remove.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the non-leaf vertex, allowing arbitrary code to be run before and/or after removing the non-leaf vertex, but whilst any mutual-exclusion locks are still acquired.  Accepts 2 parameters: the non-leaf vertex being removed, and the action which actually removes the non-leaf vertex.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddLeafToNonLeafEdge(`0,`1,System.Action{`0,`1,System.Action})">
            <summary>
            Adds an edge to the graph between the specified leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
            <param name="wrappingAction">An action which wraps the operation to add the edge, allowing arbitrary code to be run before and/or after adding the edge, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' vertex the edge connects, the 'to' vertex the edge connects, and the action which actually adds the edge.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveLeafToNonLeafEdge(`0,`1,System.Action{`0,`1,System.Action})">
            <summary>
            Removes the edge from the graph between the specified leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the edge, allowing arbitrary code to be run before and/or after removing the edge, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' vertex the edge connects, the 'to' vertex the edge connects, and the action which actually removes the edge.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AddNonLeafToNonLeafEdge(`1,`1,System.Action{`1,`1,System.Action})">
            <summary>
            Adds an edge to the graph between the specified non-leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
            <param name="wrappingAction">An action which wraps the operation to add the edge, allowing arbitrary code to be run before and/or after adding the edge, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' vertex the edge connects, the 'to' vertex the edge connects, and the action which actually adds the edge.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.RemoveNonLeafToNonLeafEdge(`1,`1,System.Action{`1,`1,System.Action})">
            <summary>
            Removes the edge from the graph between the specified non-leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
            <param name="wrappingAction">An action which wraps the operation to remove the edge, allowing arbitrary code to be run before and/or after removing the edge, but whilst any mutual-exclusion locks are still acquired.  Accepts 3 parameters: the 'from' vertex the edge connects, the 'to' vertex the edge connects, and the action which actually removes the edge.</param>
        </member>
        <member name="M:ApplicationAccess.ConcurrentDirectedGraph`2.AcquireLocksAndInvokeAction(System.Object,ApplicationAccess.Utilities.LockObjectDependencyPattern,System.Action)">
            <summary>
            Uses the 'lockManager' member to acquire locks on the specified lock object (and associated objects) depending on the value of member 'acquireLocks', and invokes the specified action.
            </summary>
            <param name="lockObject">The object to lock (if 'acquireLocks' is true).</param>
            <param name="lockObjectDependencyPattern">The dependency pattern to apply to acquire locks on objects associated with the object specified by the 'lockObject' parameter.</param>
            <param name="action">The action to invoke.</param>
        </member>
        <member name="T:ApplicationAccess.ConcurrentHashSet`1">
            <summary>
            An implementation of a HashSet which follows the same thread-safety practices as other classes in the System.Collections.Concurrent namespace.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="F:ApplicationAccess.ConcurrentHashSet`1.dictionary">
            <summary>The dictionary used to implement the set.</summary>
            <remarks>Note only the key of the dictionary is used.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentHashSet`1.#ctor">
            <summary>
            Initialises a new instance of the ApplicationAccess.ConcurrentHashSet class.
            </summary>
        </member>
        <member name="P:ApplicationAccess.ConcurrentHashSet`1.Count">
            <summary>
            The number of elements that are contained in the set.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ConcurrentHashSet`1.Add(`0)">
            <summary>
            Adds the specified element to the set.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>True if the element is added to the set.  False if the element is already present.</returns>
            <remarks>True is returned by default here which doesn't strictly match the ISet definition.  In the AccessManager use case Add() should never be called when a key already exists.</remarks>
        </member>
        <member name="M:ApplicationAccess.ConcurrentHashSet`1.Contains(`0)">
            <summary>
            Determines whether the set contains the specified element.
            </summary>
            <param name="item">The element to locate in theset.</param>
            <returns>True if the set contains the specified element.  Otherwise, false.</returns>
        </member>
        <member name="M:ApplicationAccess.ConcurrentHashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the set.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> object for the set.</returns>
        </member>
        <member name="M:ApplicationAccess.ConcurrentHashSet`1.Remove(`0)">
            <summary>
            Removes the specified element from the set.
            </summary>
            <param name="item">The element to remove.</param>
            <returns>True if the element is successfully found and removed.  Otherwise, false. This method returns false if item is not found in the set.</returns>
        </member>
        <member name="T:ApplicationAccess.DependencyFreeAccessManager`4">
            <summary>
            Subclass of <see cref="T:ApplicationAccess.ConcurrentAccessManager`4"/> where...
            <para>1. Event methods can be called successfully without first satisfying data element dependecies, e.g. the AddUserToGroupMapping() method can be used to add a user to group mapping, without first explicitly adding the user and group.</para>
            <para>2. Event methods are idempotent, e.g. the AddUserToGroupMapping() method will return success if the specified mapping already exists.</para>
            <para>3. The class passes any depended-on/prepended events to an instance of <see cref="T:ApplicationAccess.IAccessManagerEventProcessor`4"/>, e.g. if the AddUserToGroupMapping() method is called and the specified user and group do not exist, events will be passed to the <see cref="T:ApplicationAccess.IAccessManagerEventProcessor`4"/> instance to add the user and group (in addition to them being added to the class internally).</para>
            </summary>
            <typeparam name="TUser">The type of users in the application.</typeparam>
            <typeparam name="TGroup">The type of groups in the application.</typeparam>
            <typeparam name="TComponent">The type of components in the application to manage access to.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="F:ApplicationAccess.DependencyFreeAccessManager`4.eventProcessor">
            <summary>The event processor to pass any depended-on/prepended events to.</summary>
        </member>
        <member name="F:ApplicationAccess.DependencyFreeAccessManager`4.throwIdempotencyExceptions">
            <summary>Whether idempotent operation exceptions should be thrown when an Add* or Remove* event is idempotent.</summary>
        </member>
        <member name="P:ApplicationAccess.DependencyFreeAccessManager`4.EventProcessor">
            <summary>
            The event processor to pass any depended-on/prepended events to.
            </summary>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.#ctor(System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DependencyFreeAccessManager class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter <paramref name="storeBidirectionalMappings"/> is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.#ctor(ApplicationAccess.ConcurrentDirectedGraph{`0,`1},System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DependencyFreeAccessManager class.
            </summary>
            <param name="concurrentDirectedGraph">The ConcurrentDirectedGraph instance to use to store users and groups.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <remarks>If parameter <paramref name="storeBidirectionalMappings"/> is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.#ctor(ApplicationAccess.ICollectionFactory,System.Boolean,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DependencyFreeAccessManager class.
            </summary>
            <param name="collectionFactory">A mock collection factory.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <param name="throwIdempotencyExceptions">Whether idempotent operation exceptions should be thrown when an Add* or Remove* event is idempotent.</param>
            <remarks>This constructor is included to facilitate unit testing.</remarks>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.#ctor(ApplicationAccess.ConcurrentDirectedGraph{`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DependencyFreeAccessManager class.
            </summary>
            <param name="concurrentDirectedGraph">The ConcurrentDirectedGraph instance to use to store users and groups.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings between elements.</param>
            <param name="throwIdempotencyExceptions">Whether idempotent operation exceptions should be thrown when an Add* or Remove* event is idempotent.</param>
            <remarks>
              <para>If parameter <paramref name="storeBidirectionalMappings"/> is set to True, mappings between elements in the manager are stored in both directions.  This avoids slow scanning of dictionaries which store the mappings in certain operations (like RemoveEntityType()), at the cost of addition storage and hence memory usage.</para>
              <para>Setting parameter <paramref name="throwIdempotencyExceptions"/> to true provides a mechanism for classes which subclass or compose this class to detect when an Add* or Remove* event method is called idempotently, and adjust their logic accordingly.  For example, a metric logging subclass of this class would set the parameter to true, and cancel and metric logging if and idempotent operation exception was caught.</para>
            </remarks>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddUser(`0,System.Action{`0,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveUser(`0,System.Action{`0,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddGroup(`1,System.Action{`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveGroup(`1,System.Action{`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddUserToGroupMapping(`0,`1,System.Action{`0,`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveUserToGroupMapping(`0,`1,System.Action{`0,`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddGroupToGroupMapping(`1,`1,System.Action{`1,`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveGroupToGroupMapping(`1,`1,System.Action{`1,`1,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3,System.Action{`0,`2,`3,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3,System.Action{`1,`2,`3,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddEntityType(System.String,System.Action{System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveEntityType(System.String,System.Action{System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveEntityType(System.String,System.Action{`0,System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32},System.Action{`1,System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32})">
            <inheritdoc/>
            <remarks>This must be called with locks provided by base <see cref="T:ApplicationAccess.ConcurrentAccessManager`4"/> class set, e.g. via the <see cref="M:ApplicationAccess.ConcurrentAccessManager`4.RemoveEntityType(System.String,System.Action{System.String,System.Action})"/> method.</remarks>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddEntity(System.String,System.String,System.Action{System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveEntity(System.String,System.String,System.Action{System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveEntity(System.String,System.String,System.Action{`0,System.String,System.String},System.Action{`1,System.String,System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveUserToEntityMapping(`0,System.String,System.String,System.Action{`0,System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.RemoveGroupToEntityMapping(`1,System.String,System.String,System.Action{`1,System.String,System.String,System.Action})">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddUser(`0,System.Boolean)">
            <summary>
            Idempotently adds a user.
            </summary>
            <param name="user">The user to add.</param>
            <param name="generateEvent">Whether to write an event to the 'eventProcessor' member.</param>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddGroup(`1,System.Boolean)">
            <summary>
            Idempotently adds a group.
            </summary>
            <param name="group">The group to add.</param>
            <param name="generateEvent">Whether to write an event to the 'eventProcessor' member.</param>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddEntityType(System.String,System.Boolean)">
            <summary>
            Idempotently adds an entity type.
            </summary>
            <param name="entityType">The entity type to add.</param>
            <param name="generateEvent">Whether to write an event to the 'eventProcessor' member.</param>
        </member>
        <member name="M:ApplicationAccess.DependencyFreeAccessManager`4.AddEntity(System.String,System.String,System.Boolean)">
            <summary>
            Idempotently adds an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to add.</param>
            <param name="generateEvent">Whether to write an event to the 'eventProcessor' member.</param>
        </member>
        <member name="T:ApplicationAccess.DirectedGraph`2">
            <summary>
            A directed graph with different definable types for leaf and non-leaf vertices.
            </summary>
            <typeparam name="TLeaf">The type of leaf vertices.</typeparam>
            <typeparam name="TNonLeaf">The type of non-leaf vertices.</typeparam>
        </member>
        <member name="M:ApplicationAccess.DirectedGraph`2.#ctor(System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DirectedGraph class.
            </summary>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings for edges within the graph.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings for edges in the graph are stored in both directions.  This avoids slow scanning of dictionaries which store the edge mappings in certain operations (like RemoveLeafToNonLeafEdge()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="T:ApplicationAccess.DirectedGraphBase`2">
            <summary>
            A base class for directed graphs with different definable types for leaf and non-leaf vertices.
            </summary>
            <typeparam name="TLeaf">The type of leaf vertices.</typeparam>
            <typeparam name="TNonLeaf">The type of non-leaf vertices.</typeparam>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.collectionFactory">
            <summary>Creates instances of collection classes.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.leafVertices">
            <summary>The leaf vertices in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.nonLeafVertices">
            <summary>The non-leaf vertices in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.leafToNonLeafEdges">
            <summary>The edges which join leaf and non-left vertices within the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.nonLeafToNonLeafEdges">
            <summary>The edges which join non-leaf and non-left vertices within the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.storeBidirectionalMappings">
            <summary>Whether to store bidirectional mappings for edges within the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.leafToNonLeafReverseEdges">
            <summary>The reverse of the edges in member 'leafToNonLeafEdges'.</summary>
        </member>
        <member name="F:ApplicationAccess.DirectedGraphBase`2.nonLeafToNonLeafReverseEdges">
            <summary>The reverse of the edges in member 'nonLeafToNonLeafEdges'.</summary>
        </member>
        <member name="P:ApplicationAccess.DirectedGraphBase`2.LeafVertices">
            <summary>
            Returns a collection of all leaf vertices in the graph.
            </summary>
        </member>
        <member name="P:ApplicationAccess.DirectedGraphBase`2.NonLeafVertices">
            <summary>
            Returns a collection of all non-leaf vertices in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.#ctor(ApplicationAccess.ICollectionFactory,System.Boolean)">
            <summary>
            Initialises a new instance of the ApplicationAccess.DirectedGraphBase class.
            </summary>
            <param name="collectionFactory">Creates instances of collection classes.</param>
            <param name="storeBidirectionalMappings">Whether to store bidirectional mappings for edges within the graph.</param>
            <remarks>If parameter 'storeBidirectionalMappings' is set to True, mappings for edges in the graph are stored in both directions.  This avoids slow scanning of dictionaries which store the edge mappings in certain operations (like RemoveLeafToNonLeafEdge()), at the cost of addition storage and hence memory usage.</remarks>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.Clear">
            <summary>
            Removes all vertices and edges from the graph.
            </summary>
            <remarks>Since the Clear() method on HashSets and Dictionaries underlying the class are O(n) operations, performance will scale roughly with the number of vertices and edges stored in the graph.</remarks>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.AddLeafVertex(`0)">
            <summary>
            Adds a leaf vertex to the graph.
            </summary>
            <param name="leafVertex">The leaf vertex to add.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.ContainsLeafVertex(`0)">
            <summary>
            Returns true if the specified leaf vertex exists in the graph.
            </summary>
            <param name="leafVertex">The leaf vertex to check for.</param>
            <returns>True if the leaf vertex exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.RemoveLeafVertex(`0)">
            <summary>
            Removes a leaf vertex from the graph.
            </summary>
            <param name="leafVertex">The leaf vertex to remove.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.AddNonLeafVertex(`1)">
            <summary>
            Adds a non-leaf vertex to the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to add.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.ContainsNonLeafVertex(`1)">
            <summary>
            Returns true if the specified non-leaf vertex exists in the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to check for.</param>
            <returns>True if the non-leaf vertex exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.RemoveNonLeafVertex(`1)">
            <summary>
            Removes a non-leaf vertex from the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to remove.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.AddLeafToNonLeafEdge(`0,`1)">
            <summary>
            Adds an edge to the graph between the specified leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.GetLeafEdges(`0)">
            <summary>
            Gets the edges connected from the specified leaf vertex.
            </summary>
            <param name="leafVertex">The leaf vertex to retrieve the edges for.</param>
            <returns>A collection of non-leaf vertices the specified leaf vertex is connected to by an edge.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.RemoveLeafToNonLeafEdge(`0,`1)">
            <summary>
            Removes the edge from the graph between the specified leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.AddNonLeafToNonLeafEdge(`1,`1)">
            <summary>
            Adds an edge to the graph between the specified non-leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.GetNonLeafEdges(`1)">
            <summary>
            Gets the edges connected from the specified non-leaf vertex.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to retrieve the edges for.</param>
            <returns>A collection of non-leaf vertices the specified vertex is connected to by an edge.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.RemoveNonLeafToNonLeafEdge(`1,`1)">
            <summary>
            Removes the edge from the graph between the specified non-leaf and non-leaf vertices.
            </summary>
            <param name="fromVertex">The vertex which is the 'from' vertex the edge connects.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge connects.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.TraverseFromLeaf(`0,System.Func{`1,System.Boolean})">
            <summary>
            Traverses the graph, invoking the specified action at each vertex (not including the start vertex).
            </summary>
            <param name="startVertex">The leaf vertex to begin traversing at.</param>
            <param name="vertexAction">The action to perform at each non-leaf vertex.  Accepts a single parameter which is the current vertex to perform the action on, and returns a boolean indicating whether traversal should continue.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.TraverseFromNonLeaf(`1,System.Func{`1,System.Boolean})">
            <summary>
            Traverses the graph, invoking the specified action at each vertex (including the start vertex).
            </summary>
            <param name="startVertex">The non-leaf vertex to begin traversing at.</param>
            <param name="vertexAction">The action to perform at each non-leaf vertex.  Accepts a single parameter which is the current vertex to perform the action on, and returns a boolean indicating whether traversal should continue.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.RemoveNonLeafVertex(`1,System.Action{`0,`1},System.Action{`1,`1})">
            <summary>
            Removes a non-leaf vertex from the graph.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to remove.</param>
            <param name="leafToNonLeafEdgePostRemovalAction">An action which is invoked after removing a leaf to non-leaf edge containing the specified non-leaf vertex.  Accepts 2 parameters: the 'from' vertex in the edge being removed, and the the 'to' vertex in the edge being removed.</param>
            <param name="nonLeafToNonLeafEdgePostRemovalAction">An action which is invoked after removing a non-leaf to non-leaf edge containing the specified non-leaf vertex.  Accepts 2 parameters: the 'from' vertex in the edge being removed, and the the 'to' vertex in the edge being removed.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.TraverseGraph(System.Func{`0,System.Boolean},System.Func{`1,System.Boolean})">
            <summary>
            Traverses the entire graph, invoking the specified actions at each leaf and non-leaf vertex.
            </summary>
            <param name="leafVertexAction">The action to perform at leaf vertices.  Accepts a single parameter which is the current leaf vertex to perform the action on, and returns a boolean indicating whether traversal should continue.</param>
            <param name="nonLeafVertexAction">The action to perform at non-leaf vertices.  Accepts a single parameter which is the current non-leaf vertex to perform the action on, and returns a boolean indicating whether traversal should continue.</param>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.TraverseFromNonLeafRecurse(`1,System.Collections.Generic.HashSet{`1},System.Func{`1,System.Boolean})">
            <summary>
            Recurses to a non-leaf vertex as part of a traversal, invoking the specified action.
            </summary>
            <param name="nextVertex">The non-leaf vertex to recurse to.</param>
            <param name="visitedVertices">The set of vertices which have already been visited as part of the traversal.</param>
            <param name="vertexAction">The action to perform at the vertex.  Accepts a single parameter which is the current non-leaf vertex to perform the action on, and returns a boolean indicating whether traversal should continue.</param>
            <returns>Whether or not traversal should continue.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.GetLeafEdges(`0,System.Boolean)">
            <summary>
            Gets the edges connected from the specified leaf vertex.
            </summary>
            <param name="leafVertex">The leaf vertex to retrieve the edges for.</param>
            <param name="checkVertexExists">Whether or not an explicit check should be made as to whether the specified vertex exists.</param>
            <returns>A collection of non-leaf vertices the specified leaf vertex is connected to by an edge.</returns>
        </member>
        <member name="M:ApplicationAccess.DirectedGraphBase`2.GetNonLeafEdges(`1,System.Boolean)">
            <summary>
            Gets the edges connected from the specified non-leaf vertex.
            </summary>
            <param name="nonLeafVertex">The non-leaf vertex to retrieve the edges for.</param>
            <param name="checkVertexExists">Whether or not an explicit check should be made as to whether the specified vertex exists.</param>
            <returns>A collection of non-leaf vertices the specified vertex is connected to by an edge.</returns>
        </member>
        <member name="T:ApplicationAccess.EntityNotFoundException">
            <summary>
            The exception that is thrown when an entity specified in an parameter/argument does not exist.
            </summary>
        </member>
        <member name="F:ApplicationAccess.EntityNotFoundException.entityType">
            <summary>The type of the entity which does not exist.</summary>
        </member>
        <member name="F:ApplicationAccess.EntityNotFoundException.entity">
            <summary>The entity which does not exist.</summary>
        </member>
        <member name="P:ApplicationAccess.EntityNotFoundException.EntityType">
            <summary>
            The type of the entity which does not exist.
            </summary>
        </member>
        <member name="P:ApplicationAccess.EntityNotFoundException.Entity">
            <summary>
            The entity which does not exist.
            </summary>
        </member>
        <member name="M:ApplicationAccess.EntityNotFoundException.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initialises a new instance of the ApplicationAccess.EntityNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid entity.</param>
            <param name="entityType">The type of the entity which does not exist.</param>
            <param name="entity">The entity which does not exist.</param>
        </member>
        <member name="M:ApplicationAccess.EntityNotFoundException.#ctor(System.String,System.String,System.String,System.String,System.Exception)">
            <summary>
            Initialises a new instance of the ApplicationAccess.EntityNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid entity.</param>
            <param name="entityType">The type of the entity which does not exist.</param>
            <param name="entity">The entity which does not exist.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:ApplicationAccess.EntityTypeNotFoundException">
            <summary>
            The exception that is thrown when an entity type specified in an parameter/argument does not exist.
            </summary>
        </member>
        <member name="F:ApplicationAccess.EntityTypeNotFoundException.entityType">
            <summary>The entity type which does not exist.</summary>
        </member>
        <member name="P:ApplicationAccess.EntityTypeNotFoundException.EntityType">
            <summary>
            The entity type which does not exist.
            </summary>
        </member>
        <member name="M:ApplicationAccess.EntityTypeNotFoundException.#ctor(System.String,System.String,System.String)">
            <summary>
            Initialises a new instance of the ApplicationAccess.EntityTypeNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid entity type.</param>
            <param name="entityType">The entity type which does not exist.</param>
        </member>
        <member name="M:ApplicationAccess.EntityTypeNotFoundException.#ctor(System.String,System.String,System.String,System.Exception)">
            <summary>
            Initialises a new instance of the ApplicationAccess.EntityTypeNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid entity type.</param>
            <param name="entityType">The entity type which does not exist.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:ApplicationAccess.EnumUniqueStringifier`1">
            <summary>
            An implementation of <see cref="T:ApplicationAccess.IUniqueStringifier`1"/> for enums.
            </summary>
            <typeparam name="T">The type of enum to convert.</typeparam>
        </member>
        <member name="M:ApplicationAccess.EnumUniqueStringifier`1.ToString(`0)">
            <summary>
            Converts an enum value into a string.
            </summary>
            <param name="inputObject">The enum value to convert.</param>
            <returns>The enum as a string.</returns>
        </member>
        <member name="M:ApplicationAccess.EnumUniqueStringifier`1.FromString(System.String)">
            <summary>
            Converts a string into an enum value.
            </summary>
            <param name="stringifiedObject">The string representing the enum value.</param>
            <returns>The enum value.</returns>
        </member>
        <member name="T:ApplicationAccess.GroupNotFoundException`1">
            <summary>
            The exception that is thrown when a group specified in an parameter/argument does not exist.
            </summary>
            <typeparam name="T">The type of the group.</typeparam>
        </member>
        <member name="F:ApplicationAccess.GroupNotFoundException`1.group">
            <summary>The group which does not exist.</summary>
        </member>
        <member name="P:ApplicationAccess.GroupNotFoundException`1.Group">
            <summary>
            The group which does not exist.
            </summary>
        </member>
        <member name="M:ApplicationAccess.GroupNotFoundException`1.#ctor(System.String,System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.GroupNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid group.</param>
            <param name="group">The group which does not exist.</param>
        </member>
        <member name="M:ApplicationAccess.GroupNotFoundException`1.#ctor(System.String,System.String,`0,System.Exception)">
            <summary>
            Initialises a new instance of the ApplicationAccess.GroupNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid group.</param>
            <param name="group">The group which does not exist.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:ApplicationAccess.IAccessManager`4">
            <summary>
            Defines methods to manage the access of users and groups of users to components and entities within an application.
            </summary>
            <typeparam name="TUser">The type of users in the application.</typeparam>
            <typeparam name="TGroup">The type of groups in the application.</typeparam>
            <typeparam name="TComponent">The type of components in the application to manage access to.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerAsyncEventProcessor`4">
            <summary>
            Defines methods to process events which change the structure of an AccessManager implementation as asyncronous operations.
            </summary>
            <typeparam name="TUser">The type of users in the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddUserAsync(`0)">
            <summary>
            Adds a user as an asyncronous operation.
            </summary>
            <param name="user">The user to add.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveUserAsync(`0)">
            <summary>
            Removes a user as an asyncronous operation.
            </summary>
            <param name="user">The user to remove.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddGroupAsync(`1)">
            <summary>
            Adds a group as an asyncronous operation.
            </summary>
            <param name="group">The group to add.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveGroupAsync(`1)">
            <summary>
            Removes a group as an asyncronous operation.
            </summary>
            <param name="group">The group to remove.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddUserToGroupMappingAsync(`0,`1)">
            <summary>
            Adds a mapping between the specified user and group as an asyncronous operation as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveUserToGroupMappingAsync(`0,`1)">
            <summary>
            Removes the mapping between the specified user and group as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddGroupToGroupMappingAsync(`1,`1)">
            <summary>
            Adds a mapping between the specified groups as an asyncronous operation.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveGroupToGroupMappingAsync(`1,`1)">
            <summary>
            Removes the mapping between the specified groups as an asyncronous operation.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddUserToApplicationComponentAndAccessLevelMappingAsync(`0,`2,`3)">
            <summary>
            Adds a mapping between the specified user, application component, and level of access to that component as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveUserToApplicationComponentAndAccessLevelMappingAsync(`0,`2,`3)">
            <summary>
            Removes a mapping between the specified user, application component, and level of access to that component as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddGroupToApplicationComponentAndAccessLevelMappingAsync(`1,`2,`3)">
            <summary>
            Adds a mapping between the specified group, application component, and level of access to that component as an asyncronous operation.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveGroupToApplicationComponentAndAccessLevelMappingAsync(`1,`2,`3)">
            <summary>
            Removes a mapping between the specified group, application component, and level of access to that component as an asyncronous operation.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddEntityTypeAsync(System.String)">
            <summary>
            Adds an entity type as an asyncronous operation.
            </summary>
            <param name="entityType">The entity type to add.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveEntityTypeAsync(System.String)">
            <summary>
            Removes an entity type as an asyncronous operation.
            </summary>
            <param name="entityType">The entity type to remove.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddEntityAsync(System.String,System.String)">
            <summary>
            Adds an entity as an asyncronous operation.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to add.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveEntityAsync(System.String,System.String)">
            <summary>
            Removes an entity as an asyncronous operation.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to remove.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddUserToEntityMappingAsync(`0,System.String,System.String)">
            <summary>
            Adds a mapping between the specified user, and entity as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveUserToEntityMappingAsync(`0,System.String,System.String)">
            <summary>
            Removes a mapping between the specified user, and entity as an asyncronous operation.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.AddGroupToEntityMappingAsync(`1,System.String,System.String)">
            <summary>
            Adds a mapping between the specified group, and entity as an asyncronous operation.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncEventProcessor`4.RemoveGroupToEntityMappingAsync(`1,System.String,System.String)">
            <summary>
            Removes a mapping between the specified group, and entity as an asyncronous operation.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
            <returns>The task object representing the asynronous operation.</returns>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4">
            <summary>
            Defines methods which query the state/structure of an AccessManager implementation as asyncronous operations.
            </summary>
            <typeparam name="TUser">The type of users in the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetUsersAsync">
            <summary>
            Returns a list of all users in the access manager as an asyncronous operation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetGroupsAsync">
            <summary>
            Returns a list of all groups in the access manager as an asyncronous operation.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntityTypesAsync">
            <summary>
            Returns a list of all entity types in the access manager as an asyncronous operation.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.ContainsUserAsync(`0)">
            <summary>
            Returns true if the specified user exists as an asyncronous operation.
            </summary>
            <param name="user">The user to check for.</param>
            <returns>True if the user exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.ContainsGroupAsync(`1)">
            <summary>
            Returns true if the specified group exists as an asyncronous operation.
            </summary>
            <param name="group">The group to check for.</param>
            <returns>True if the group exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetUserToGroupMappingsAsync(`0,System.Boolean)">
            <summary>
            Gets the groups that the specified user is mapped to (i.e. is a member of) as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the groups for.</param>
            <param name="includeIndirectMappings">Whether to include indirect mappings (i.e. those that occur via group to group mappings).</param>
            <returns>A list of groups the specified user is a member of.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetGroupToGroupMappingsAsync(`1,System.Boolean)">
            <summary>
            Gets the groups that the specified group is mapped to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the mapped groups for.</param>
            <param name="includeIndirectMappings">Whether to include indirect mappings (i.e. those where the 'mapped to' group is itself mapped to further groups).</param>
            <returns>A list of groups the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetUserToApplicationComponentAndAccessLevelMappingsAsync(`0)">
            <summary>
            Gets the application component and access level pairs that the specified user is mapped to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <returns>A list of Tuples containing the application component and access level pairs that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetGroupToApplicationComponentAndAccessLevelMappingsAsync(`1)">
            <summary>
            Gets the application component and access level pairs that the specified group is mapped to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <returns>A list of Tuples containing the application component and access level pairs that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.ContainsEntityTypeAsync(System.String)">
            <summary>
            Returns true if the specified entity type exists as an asyncronous operation.
            </summary>
            <param name="entityType">The entity type to check for.</param>
            <returns>True if the entity type exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntitiesAsync(System.String)">
            <summary>
            Returns all entities of the specified type as an asyncronous operation.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <returns>A list of all entities of the specified type.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.ContainsEntityAsync(System.String,System.String)">
            <summary>
            Returns true if the specified entity exists as an asyncronous operation.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to check for.</param>
            <returns>True if the entity exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetUserToEntityMappingsAsync(`0)">
            <summary>
            Gets the entities that the specified user is mapped to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <returns>A list of Tuples containing the entity type and entity that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetUserToEntityMappingsAsync(`0,System.String)">
            <summary>
            Gets the entities of a given type that the specified user is mapped to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <param name="entityType">The entity type to retrieve the mappings for.</param>
            <returns>A list of entities that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetGroupToEntityMappingsAsync(`1)">
            <summary>
            Gets the entities that the specified group is mapped to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <returns>A list of Tuples containing the entity type and entity that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetGroupToEntityMappingsAsync(`1,System.String)">
            <summary>
            Gets the entities of a given type that the specified group is mapped to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <param name="entityType">The entity type to retrieve the mappings for.</param>
            <returns>A list of entities that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.HasAccessToApplicationComponentAsync(`0,`2,`3)">
            <summary>
            Checks whether the specified user (or a group that the user is a member of) has access to an application component at the specified level of access as an asyncronous operation.
            </summary>
            <param name="user">The user to check for.</param>
            <param name="applicationComponent">The application component.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>True if the user has access the component.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.HasAccessToEntityAsync(`0,System.String,System.String)">
            <summary>
            Checks whether the specified user (or a group that the user is a member of) has access to the specified entity as an asyncronous operation.
            </summary>
            <param name="user">The user to check for.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity.</param>
            <returns>True if the user has access the entity.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetApplicationComponentsAccessibleByUserAsync(`0)">
            <summary>
            Gets all application components and levels of access that the specified user (or a group that the user is a member of) has access to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the application components and levels of access for.</param>
            <returns>The application components and levels of access to those application components that the user has.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetApplicationComponentsAccessibleByGroupAsync(`1)">
            <summary>
            Gets all application components and levels of access that the specified group (or group that the specified group is mapped to) has access to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the application components and levels of access for.</param>
            <returns>The application components and levels of access to those application components that the group has.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntitiesAccessibleByUserAsync(`0)">
            <summary>
            Gets all entities that the specified user (or a group that the user is a member of) has access to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the entities for.</param>
            <returns>A list of Tuples containing the entity type and entity that the user has access to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntitiesAccessibleByUserAsync(`0,System.String)">
            <summary>
            Gets all entities of a given type that the specified user (or a group that the user is a member of) has access to as an asyncronous operation.
            </summary>
            <param name="user">The user to retrieve the entities for.</param>
            <param name="entityType">The type of entities to retrieve.</param>
            <returns>The entities the user has access to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntitiesAccessibleByGroupAsync(`1)">
            <summary>
            Gets all entities that the specified group (or group that the specified group is mapped to) has access to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the entities for.</param>
            <returns>A list of Tuples containing the entity type and entity that the group has access to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerAsyncQueryProcessor`4.GetEntitiesAccessibleByGroupAsync(`1,System.String)">
            <summary>
            Gets all entities of a given type that the specified group (or group that the specified group is mapped to) has access to as an asyncronous operation.
            </summary>
            <param name="group">The group to retrieve the entities for.</param>
            <param name="entityType">The type of entities to retrieve.</param>
            <returns>The entities the group has access to.</returns>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerEntityEventProcessor">
            <summary>
            Defines methods to process events which change entity-based structures in an AccessManager implementation.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityEventProcessor.AddEntityType(System.String)">
            <summary>
            Adds an entity type.
            </summary>
            <param name="entityType">The entity type to add.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityEventProcessor.RemoveEntityType(System.String)">
            <summary>
            Removes an entity type.
            </summary>
            <param name="entityType">The entity type to remove.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityEventProcessor.AddEntity(System.String,System.String)">
            <summary>
            Adds an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to add.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityEventProcessor.RemoveEntity(System.String,System.String)">
            <summary>
            Removes an entity.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to remove.</param>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerEntityQueryProcessor">
            <summary>
             Defines methods which query the state of entity-based structures in an AccessManager implementation.
            </summary>
        </member>
        <member name="P:ApplicationAccess.IAccessManagerEntityQueryProcessor.EntityTypes">
            <summary>
            Returns a collection of all entity types in the access manager.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityQueryProcessor.ContainsEntityType(System.String)">
            <summary>
            Returns true if the specified entity type exists.
            </summary>
            <param name="entityType">The entity type to check for.</param>
            <returns>True if the entity type exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityQueryProcessor.GetEntities(System.String)">
            <summary>
            Returns all entities of the specified type.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <returns>A collection of all entities of the specified type.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerEntityQueryProcessor.ContainsEntity(System.String,System.String)">
            <summary>
            Returns true if the specified entity exists.
            </summary>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity to check for.</param>
            <returns>True if the entity exists.  False otherwise.</returns>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerEventProcessor`4">
            <summary>
            Defines methods to process events which change the structure of an AccessManager implementation.
            </summary>
            <typeparam name="TUser">The type of users in the application managed by the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerGroupEventProcessor`3">
            <summary>
            Defines methods to process events which change group-based structures in an AccessManager implementation.
            </summary>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.AddGroup(`0)">
            <summary>
            Adds a group.
            </summary>
            <param name="group">The group to add.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.RemoveGroup(`0)">
            <summary>
            Removes a group.
            </summary>
            <param name="group">The group to remove.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.AddGroupToApplicationComponentAndAccessLevelMapping(`0,`1,`2)">
            <summary>
            Adds a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.RemoveGroupToApplicationComponentAndAccessLevelMapping(`0,`1,`2)">
            <summary>
            Removes a mapping between the specified group, application component, and level of access to that component.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.AddGroupToEntityMapping(`0,System.String,System.String)">
            <summary>
            Adds a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupEventProcessor`3.RemoveGroupToEntityMapping(`0,System.String,System.String)">
            <summary>
            Removes a mapping between the specified group, and entity.
            </summary>
            <param name="group">The group in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerGroupQueryProcessor`3">
            <summary>
            Defines methods which query the state of group-based structures in an AccessManager implementation.
            </summary>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="P:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.Groups">
            <summary>
            Returns a collection of all groups in the access manager.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.ContainsGroup(`0)">
            <summary>
            Returns true if the specified group exists.
            </summary>
            <param name="group">The group to check for.</param>
            <returns>True if the group exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetGroupToApplicationComponentAndAccessLevelMappings(`0)">
            <summary>
            Gets the application component and access level pairs that the specified group is mapped to.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the application component and access level pairs that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetGroupToEntityMappings(`0)">
            <summary>
            Gets the entities that the specified group is mapped to.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetGroupToEntityMappings(`0,System.String)">
            <summary>
            Gets the entities of a given type that the specified group is mapped to.
            </summary>
            <param name="group">The group to retrieve the mappings for.</param>
            <param name="entityType">The entity type to retrieve the mappings for.</param>
            <returns>A collection of entities that the specified group is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetApplicationComponentsAccessibleByGroup(`0)">
            <summary>
            Gets all application components and levels of access that the specified group (or group that the specified group is mapped to) has access to.
            </summary>
            <param name="group">The group to retrieve the application components and levels of access for.</param>
            <returns>The application components and levels of access to those application components that the group has.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetEntitiesAccessibleByGroup(`0)">
            <summary>
            Gets all entities that the specified group (or group that the specified group is mapped to) has access to.
            </summary>
            <param name="group">The group to retrieve the entities for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the group has access to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupQueryProcessor`3.GetEntitiesAccessibleByGroup(`0,System.String)">
            <summary>
            Gets all entities of a given type that the specified group (or group that the specified group is mapped to) has access to.
            </summary>
            <param name="group">The group to retrieve the entities for.</param>
            <param name="entityType">The type of entities to retrieve.</param>
            <returns>The entities the group has access to.</returns>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerGroupToGroupEventProcessor`1">
            <summary>
            Defines methods to process events which change group to group mapping structures in an AccessManager implementation.
            </summary>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupToGroupEventProcessor`1.AddGroupToGroupMapping(`0,`0)">
            <summary>
            Adds a mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupToGroupEventProcessor`1.RemoveGroupToGroupMapping(`0,`0)">
            <summary>
            Removes the mapping between the specified groups.
            </summary>
            <param name="fromGroup">The 'from' group in the mapping.</param>
            <param name="toGroup">The 'to' group in the mapping.</param>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerGroupToGroupQueryProcessor`1">
            <summary>
            Defines methods which query the state of group to group mapping structures in an AccessManager implementation.
            </summary>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerGroupToGroupQueryProcessor`1.GetGroupToGroupMappings(`0,System.Boolean)">
            <summary>
            Gets the groups that the specified group is mapped to.
            </summary>
            <param name="group">The group to retrieve the mapped groups for.</param>
            <param name="includeIndirectMappings">Whether to include indirect mappings (i.e. those where the 'mapped to' group is itself mapped to further groups).</param>
            <returns>A collection of groups the specified group is mapped to.</returns>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerQueryProcessor`4">
            <summary>
            Defines methods which query the state/structure of an AccessManager implementation.
            </summary>
            <typeparam name="TUser">The type of users in the application managed by the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerUserEventProcessor`4">
            <summary>
            Defines methods to process events which change user-based structures in an AccessManager implementation.
            </summary>
            <typeparam name="TUser">The type of users in the application managed by the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.AddUser(`0)">
            <summary>
            Adds a user.
            </summary>
            <param name="user">The user to add.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.RemoveUser(`0)">
            <summary>
            Removes a user.
            </summary>
            <param name="user">The user to remove.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.AddUserToGroupMapping(`0,`1)">
            <summary>
            Adds a mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.RemoveUserToGroupMapping(`0,`1)">
            <summary>
            Removes the mapping between the specified user and group.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="group">The group in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <summary>
            Adds a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <summary>
            Removes a mapping between the specified user, application component, and level of access to that component.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="applicationComponent">The application component in the mapping.</param>
            <param name="accessLevel">The level of access to the component.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.AddUserToEntityMapping(`0,System.String,System.String)">
            <summary>
            Adds a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserEventProcessor`4.RemoveUserToEntityMapping(`0,System.String,System.String)">
            <summary>
            Removes a mapping between the specified user, and entity.
            </summary>
            <param name="user">The user in the mapping.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity in the mapping.</param>
        </member>
        <member name="T:ApplicationAccess.IAccessManagerUserQueryProcessor`4">
            <summary>
            Defines methods which query the state of user-based structures in an AccessManager implementation.
            </summary>
            <typeparam name="TUser">The type of users in the application managed by the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="P:ApplicationAccess.IAccessManagerUserQueryProcessor`4.Users">
            <summary>
            Returns a collection of all users in the access manager.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.ContainsUser(`0)">
            <summary>
            Returns true if the specified user exists.
            </summary>
            <param name="user">The user to check for.</param>
            <returns>True if the user exists.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetUserToGroupMappings(`0,System.Boolean)">
            <summary>
            Gets the groups that the specified user is mapped to (i.e. is a member of).
            </summary>
            <param name="user">The user to retrieve the groups for.</param>
            <param name="includeIndirectMappings">Whether to include indirect mappings (i.e. those that occur via group to group mappings).</param>
            <returns>A collection of groups the specified user is a member of.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetUserToApplicationComponentAndAccessLevelMappings(`0)">
            <summary>
            Gets the application component and access level pairs that the specified user is mapped to.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the application component and access level pairs that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetUserToEntityMappings(`0)">
            <summary>
            Gets the entities that the specified user is mapped to.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetUserToEntityMappings(`0,System.String)">
            <summary>
            Gets the entities of a given type that the specified user is mapped to.
            </summary>
            <param name="user">The user to retrieve the mappings for.</param>
            <param name="entityType">The entity type to retrieve the mappings for.</param>
            <returns>A collection of entities that the specified user is mapped to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.HasAccessToApplicationComponent(`0,`2,`3)">
            <summary>
            Checks whether the specified user (or a group that the user is a member of) has access to an application component at the specified level of access.
            </summary>
            <param name="user">The user to check for.</param>
            <param name="applicationComponent">The application component.</param>
            <param name="accessLevel">The level of access to the component.</param>
            <returns>True if the user has access the component.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.HasAccessToEntity(`0,System.String,System.String)">
            <summary>
            Checks whether the specified user (or a group that the user is a member of) has access to the specified entity.
            </summary>
            <param name="user">The user to check for.</param>
            <param name="entityType">The type of the entity.</param>
            <param name="entity">The entity.</param>
            <returns>True if the user has access the entity.  False otherwise.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetApplicationComponentsAccessibleByUser(`0)">
            <summary>
            Gets all application components and levels of access that the specified user (or a group that the user is a member of) has access to.
            </summary>
            <param name="user">The user to retrieve the application components and levels of access for.</param>
            <returns>The application components and levels of access to those application components that the user has.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetEntitiesAccessibleByUser(`0)">
            <summary>
            Gets all entities that the specified user (or a group that the user is a member of) has access to.
            </summary>
            <param name="user">The user to retrieve the entities for.</param>
            <returns>A collection of Tuples containing the entity type and entity that the user has access to.</returns>
        </member>
        <member name="M:ApplicationAccess.IAccessManagerUserQueryProcessor`4.GetEntitiesAccessibleByUser(`0,System.String)">
            <summary>
            Gets all entities of a given type that the specified user (or a group that the user is a member of) has access to.
            </summary>
            <param name="user">The user to retrieve the entities for.</param>
            <param name="entityType">The type of entities to retrieve.</param>
            <returns>The entities the user has access to.</returns>
        </member>
        <member name="T:ApplicationAccess.ICollectionFactory">
            <summary>
            Defines methods which follow a factory pattern to return instances of collection classes.
            </summary>
        </member>
        <member name="M:ApplicationAccess.ICollectionFactory.GetDictionaryInstance``2">
            <summary>
            Returns an IDictionary instance.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns>The IDictionary instance.</returns>
        </member>
        <member name="M:ApplicationAccess.ICollectionFactory.GetSetInstance``1">
            <summary>
            Returns an ISet instance.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <returns>The ISet instance</returns>
        </member>
        <member name="T:ApplicationAccess.IdempotentAddOperationException">
            <summary>
            The exception that is thrown when an 'Add' operation or event is idempotent (i.e. does not change the object its applied to or raised against).
            </summary>
        </member>
        <member name="M:ApplicationAccess.IdempotentAddOperationException.#ctor">
            <summary>
            Initialises a new instance of the ApplicationAccess.IdempotentAddOperationException class.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IdempotentAddOperationException.#ctor(System.String)">
            <summary>
            Initialises a new instance of the ApplicationAccess.IdempotentAddOperationException class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:ApplicationAccess.IdempotentRemoveOperationException">
            <summary>
            The exception that is thrown when a 'Remove' operation or event is idempotent (i.e. does not change the object its applied to or raised against).
            </summary>
        </member>
        <member name="M:ApplicationAccess.IdempotentRemoveOperationException.#ctor">
            <summary>
            Initialises a new instance of the ApplicationAccess.IdempotentRemoveOperationException class.
            </summary>
        </member>
        <member name="M:ApplicationAccess.IdempotentRemoveOperationException.#ctor(System.String)">
            <summary>
            Initialises a new instance of the ApplicationAccess.IdempotentRemoveOperationException class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:ApplicationAccess.IUniqueStringifier`1">
            <summary>
            Defines methods for converting objects of a specified type to and from strings which uniquely identify the object.
            </summary>
            <typeparam name="T">The type of objects to convert.</typeparam>
        </member>
        <member name="M:ApplicationAccess.IUniqueStringifier`1.ToString(`0)">
            <summary>
            Converts an object into a string which uniquely identifies that object.
            </summary>
            <param name="inputObject">The object to convert.</param>
            <returns>A string which uniquely identifies that object.</returns>
        </member>
        <member name="M:ApplicationAccess.IUniqueStringifier`1.FromString(System.String)">
            <summary>
            Converts a string which uniquely identifies an object into the object.
            </summary>
            <param name="stringifiedObject">The string representing the object.</param>
            <returns>The object.</returns>
        </member>
        <member name="T:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2">
            <summary>
            The exception that is thrown when a specified leaf to non-leaf edge of a DirectedGraph already exists in the graph.
            </summary>
            <typeparam name="TLeaf">The type of leaf vertices in the graph.</typeparam>
            <typeparam name="TNonLeaf">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2.fromVertex">
            <summary>The vertex which is the 'from' vertex of the edge which already exists in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2.toVertex">
            <summary>The vertex which is the 'to' vertex of the edge which already exists in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2.FromVertex">
            <summary>
            The vertex which is the 'from' vertex of the edge which already exists in the graph.
            </summary>
        </member>
        <member name="P:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2.ToVertex">
            <summary>
            The vertex which is the 'to' vertex of the edge which already exists in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException`2.#ctor(System.String,`0,`1)">
            <summary>
            Initialises a new instance of the ApplicationAccess.LeafToNonLeafEdgeAlreadyExistsException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="fromVertex">The vertex which is the 'from' vertex of the edge which already exists in the graph.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge which already exists in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2">
            <summary>
            The exception that is thrown when a specified leaf to non-leaf edge of a DirectedGraph does not exist in the graph.
            </summary>
            <typeparam name="TLeaf">The type of leaf vertices in the graph.</typeparam>
            <typeparam name="TNonLeaf">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2.fromVertex">
            <summary>The vertex which is the 'from' vertex of the edge which does not exist in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2.toVertex">
            <summary>The vertex which is the 'to' vertex of the edge which does not exist in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2.FromVertex">
            <summary>
            The vertex which is the 'from' vertex of the edge which does not exist in the graph.
            </summary>
        </member>
        <member name="P:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2.ToVertex">
            <summary>
            The vertex which is the 'to' vertex of the edge which does not exist in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.LeafToNonLeafEdgeNotFoundException`2.#ctor(System.String,`0,`1)">
            <summary>
            Initialises a new instance of the ApplicationAccess.LeafToNonLeafEdgeNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="fromVertex">The vertex which is the 'from' vertex of the edge which does not exist in the graph.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge which does not exist in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.LeafVertexAlreadyExistsException`1">
            <summary>
            The exception that is thrown when a specified leaf vertex of a DirectedGraph already exists in the graph.
            </summary>
            <typeparam name="T">The type of leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.LeafVertexAlreadyExistsException`1.leafVertex">
            <summary>The leaf vertex which already exists in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.LeafVertexAlreadyExistsException`1.LeafVertex">
            <summary>
            The leaf vertex which already exists in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.LeafVertexAlreadyExistsException`1.#ctor(System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.LeafVertexAlreadyExistsException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="leafVertex">The leaf vertex which already exists in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.LeafVertexNotFoundException`1">
            <summary>
            The exception that is thrown when a specified leaf vertex of a DirectedGraph does not exist in the graph.
            </summary>
            <typeparam name="T">The type of leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.LeafVertexNotFoundException`1.leafVertex">
            <summary>The leaf vertex which does not exist in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.LeafVertexNotFoundException`1.LeafVertex">
            <summary>
            The leaf vertex which does not exist in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.LeafVertexNotFoundException`1.#ctor(System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.LeafVertexNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="leafVertex">The leaf vertex which does not exist in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1">
            <summary>
            The exception that is thrown when a specified non-leaf to non-leaf edge of a DirectedGraph already exists in the graph.
            </summary>
            <typeparam name="TNonLeaf">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1.fromVertex">
            <summary>The vertex which is the 'from' vertex of the edge which already exists in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1.toVertex">
            <summary>The vertex which is the 'to' vertex of the edge which already exists in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1.FromVertex">
            <summary>
            The vertex which is the 'from' vertex of the edge which already exists in the graph.
            </summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1.ToVertex">
            <summary>
            The vertex which is the 'to' vertex of the edge which already exists in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException`1.#ctor(System.String,`0,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.NonLeafToNonLeafEdgeAlreadyExistsException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="fromVertex">The vertex which is the 'from' vertex of the edge which already exists in the graph.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge which already exists in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1">
            <summary>
            The exception that is thrown when a specified non-leaf to non-leaf edge of a DirectedGraph does not exist in the graph.
            </summary>
            <typeparam name="TNonLeaf">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1.fromVertex">
            <summary>The vertex which is the 'from' vertex of the edge which does not exist in the graph.</summary>
        </member>
        <member name="F:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1.toVertex">
            <summary>The vertex which is the 'to' vertex of the edge which does not exist in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1.FromVertex">
            <summary>
            The vertex which is the 'from' vertex of the edge which does not exist in the graph.
            </summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1.ToVertex">
            <summary>
            The vertex which is the 'to' vertex of the edge which does not exist in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException`1.#ctor(System.String,`0,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.NonLeafToNonLeafEdgeNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="fromVertex">The vertex which is the 'from' vertex of the edge which does not exist in the graph.</param>
            <param name="toVertex">The vertex which is the 'to' vertex of the edge which does not exist in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.NonLeafVertexAlreadyExistsException`1">
            <summary>
            The exception that is thrown when a specified non-leaf vertex of a DirectedGraph already exists in the graph.
            </summary>
            <typeparam name="T">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.NonLeafVertexAlreadyExistsException`1.nonLeafVertex">
            <summary>The non-leaf vertex which already exists in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafVertexAlreadyExistsException`1.NonLeafVertex">
            <summary>
            The non-leaf vertex which already exists in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.NonLeafVertexAlreadyExistsException`1.#ctor(System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.NonLeafVertexAlreadyExistsException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="nonLeafVertex">The non-leaf vertex which already exists in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.NonLeafVertexNotFoundException`1">
            <summary>
            The exception that is thrown when a specified non-leaf vertex of a DirectedGraph does not exist in the graph.
            </summary>
            <typeparam name="T">The type of non-leaf vertices in the graph.</typeparam>
        </member>
        <member name="F:ApplicationAccess.NonLeafVertexNotFoundException`1.nonLeafVertex">
            <summary>The non-leaf vertex which does not exist in the graph.</summary>
        </member>
        <member name="P:ApplicationAccess.NonLeafVertexNotFoundException`1.NonLeafVertex">
            <summary>
            The non-leaf vertex which does not exist in the graph.
            </summary>
        </member>
        <member name="M:ApplicationAccess.NonLeafVertexNotFoundException`1.#ctor(System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.NonLeafVertexNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="nonLeafVertex">The non-leaf vertex which does not exist in the graph.</param>
        </member>
        <member name="T:ApplicationAccess.NullAccessManagerEventProcessor`4">
            <summary>
            Implementation of <see cref="T:ApplicationAccess.IAccessManagerEventProcessor`4"/> which does not process any events.
            </summary>
            <typeparam name="TUser">The type of users in the application managed by the AccessManager.</typeparam>
            <typeparam name="TGroup">The type of groups in the application managed by the AccessManager.</typeparam>
            <typeparam name="TComponent">The type of components in the application managed by the AccessManager.</typeparam>
            <typeparam name="TAccess">The type of levels of access which can be assigned to an application component.</typeparam>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveUser(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveGroup(`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddUserToGroupMapping(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveUserToGroupMapping(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveGroupToGroupMapping(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveUserToApplicationComponentAndAccessLevelMapping(`0,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveGroupToApplicationComponentAndAccessLevelMapping(`1,`2,`3)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveEntityType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveEntity(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveUserToEntityMapping(`0,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.AddGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ApplicationAccess.NullAccessManagerEventProcessor`4.RemoveGroupToEntityMapping(`1,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:ApplicationAccess.StandardCollectionFactory">
            <summary>
            Returns instances of standard collections in the System.Collections.Generic namespace.
            </summary>
        </member>
        <member name="M:ApplicationAccess.StandardCollectionFactory.GetDictionaryInstance``2">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.Dictionary`2"/> instance.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <returns>The <see cref="T:System.Collections.Generic.Dictionary`2"/> instance.</returns>
        </member>
        <member name="M:ApplicationAccess.StandardCollectionFactory.GetSetInstance``1">
            <summary>
            Returns a <see cref="T:System.Collections.Generic.HashSet`1"/> instance.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <returns>The <see cref="T:System.Collections.Generic.HashSet`1"/> instance</returns>
        </member>
        <member name="T:ApplicationAccess.StringUniqueStringifier">
            <summary>
            An implementation of <see cref="T:ApplicationAccess.IUniqueStringifier`1"/> for strings.
            </summary>
            <remarks>Methods simply return the respective string parameters immediately.</remarks>
        </member>
        <member name="T:ApplicationAccess.UserNotFoundException`1">
            <summary>
            The exception that is thrown when a user specified in an parameter/argument does not exist.
            </summary>
            <typeparam name="T">The type of the user.</typeparam>
        </member>
        <member name="F:ApplicationAccess.UserNotFoundException`1.user">
            <summary>The user which does not exist.</summary>
        </member>
        <member name="P:ApplicationAccess.UserNotFoundException`1.User">
            <summary>
            The user which does not exist.
            </summary>
        </member>
        <member name="M:ApplicationAccess.UserNotFoundException`1.#ctor(System.String,System.String,`0)">
            <summary>
            Initialises a new instance of the ApplicationAccess.UserNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid user.</param>
            <param name="user">The user which does not exist.</param>
        </member>
        <member name="M:ApplicationAccess.UserNotFoundException`1.#ctor(System.String,System.String,`0,System.Exception)">
            <summary>
            Initialises a new instance of the ApplicationAccess.UserNotFoundException class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="parameterName">The name of the parameter containing the invalid user.</param>
            <param name="user">The user which does not exist.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
    </members>
</doc>
